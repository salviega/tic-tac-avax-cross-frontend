{
  "language": "Solidity",
  "sources": {
    "@axelar-network/axelar-gmp-sdk-solidity/contracts/executable/AxelarExecutable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport { IAxelarGateway } from '../interfaces/IAxelarGateway.sol';\nimport { IAxelarExecutable } from '../interfaces/IAxelarExecutable.sol';\n\ncontract AxelarExecutable is IAxelarExecutable {\n    IAxelarGateway public immutable gateway;\n\n    constructor(address gateway_) {\n        if (gateway_ == address(0)) revert InvalidAddress();\n\n        gateway = IAxelarGateway(gateway_);\n    }\n\n    function execute(\n        bytes32 commandId,\n        string calldata sourceChain,\n        string calldata sourceAddress,\n        bytes calldata payload\n    ) external {\n        bytes32 payloadHash = keccak256(payload);\n\n        if (!gateway.validateContractCall(commandId, sourceChain, sourceAddress, payloadHash))\n            revert NotApprovedByGateway();\n\n        _execute(sourceChain, sourceAddress, payload);\n    }\n\n    function executeWithToken(\n        bytes32 commandId,\n        string calldata sourceChain,\n        string calldata sourceAddress,\n        bytes calldata payload,\n        string calldata tokenSymbol,\n        uint256 amount\n    ) external {\n        bytes32 payloadHash = keccak256(payload);\n\n        if (\n            !gateway.validateContractCallAndMint(\n                commandId,\n                sourceChain,\n                sourceAddress,\n                payloadHash,\n                tokenSymbol,\n                amount\n            )\n        ) revert NotApprovedByGateway();\n\n        _executeWithToken(sourceChain, sourceAddress, payload, tokenSymbol, amount);\n    }\n\n    function _execute(\n        string calldata sourceChain,\n        string calldata sourceAddress,\n        bytes calldata payload\n    ) internal virtual {}\n\n    function _executeWithToken(\n        string calldata sourceChain,\n        string calldata sourceAddress,\n        bytes calldata payload,\n        string calldata tokenSymbol,\n        uint256 amount\n    ) internal virtual {}\n}\n"
    },
    "@axelar-network/axelar-gmp-sdk-solidity/contracts/interfaces/IAxelarExecutable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport { IAxelarGateway } from './IAxelarGateway.sol';\n\ninterface IAxelarExecutable {\n    error InvalidAddress();\n    error NotApprovedByGateway();\n\n    function gateway() external view returns (IAxelarGateway);\n\n    function execute(\n        bytes32 commandId,\n        string calldata sourceChain,\n        string calldata sourceAddress,\n        bytes calldata payload\n    ) external;\n\n    function executeWithToken(\n        bytes32 commandId,\n        string calldata sourceChain,\n        string calldata sourceAddress,\n        bytes calldata payload,\n        string calldata tokenSymbol,\n        uint256 amount\n    ) external;\n}\n"
    },
    "@axelar-network/axelar-gmp-sdk-solidity/contracts/interfaces/IAxelarGasService.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport { GasInfo } from '../types/GasEstimationTypes.sol';\nimport { IInterchainGasEstimation } from './IInterchainGasEstimation.sol';\nimport { IUpgradable } from './IUpgradable.sol';\n\n/**\n * @title IAxelarGasService Interface\n * @notice This is an interface for the AxelarGasService contract which manages gas payments\n * and refunds for cross-chain communication on the Axelar network.\n * @dev This interface inherits IUpgradable\n */\ninterface IAxelarGasService is IInterchainGasEstimation, IUpgradable {\n    error InvalidAddress();\n    error NotCollector();\n    error InvalidAmounts();\n    error InvalidGasUpdates();\n    error InvalidParams();\n    error InsufficientGasPayment(uint256 required, uint256 provided);\n\n    event GasPaidForContractCall(\n        address indexed sourceAddress,\n        string destinationChain,\n        string destinationAddress,\n        bytes32 indexed payloadHash,\n        address gasToken,\n        uint256 gasFeeAmount,\n        address refundAddress\n    );\n\n    event GasPaidForContractCallWithToken(\n        address indexed sourceAddress,\n        string destinationChain,\n        string destinationAddress,\n        bytes32 indexed payloadHash,\n        string symbol,\n        uint256 amount,\n        address gasToken,\n        uint256 gasFeeAmount,\n        address refundAddress\n    );\n\n    event NativeGasPaidForContractCall(\n        address indexed sourceAddress,\n        string destinationChain,\n        string destinationAddress,\n        bytes32 indexed payloadHash,\n        uint256 gasFeeAmount,\n        address refundAddress\n    );\n\n    event NativeGasPaidForContractCallWithToken(\n        address indexed sourceAddress,\n        string destinationChain,\n        string destinationAddress,\n        bytes32 indexed payloadHash,\n        string symbol,\n        uint256 amount,\n        uint256 gasFeeAmount,\n        address refundAddress\n    );\n\n    event GasPaidForExpressCall(\n        address indexed sourceAddress,\n        string destinationChain,\n        string destinationAddress,\n        bytes32 indexed payloadHash,\n        address gasToken,\n        uint256 gasFeeAmount,\n        address refundAddress\n    );\n\n    event GasPaidForExpressCallWithToken(\n        address indexed sourceAddress,\n        string destinationChain,\n        string destinationAddress,\n        bytes32 indexed payloadHash,\n        string symbol,\n        uint256 amount,\n        address gasToken,\n        uint256 gasFeeAmount,\n        address refundAddress\n    );\n\n    event NativeGasPaidForExpressCall(\n        address indexed sourceAddress,\n        string destinationChain,\n        string destinationAddress,\n        bytes32 indexed payloadHash,\n        uint256 gasFeeAmount,\n        address refundAddress\n    );\n\n    event NativeGasPaidForExpressCallWithToken(\n        address indexed sourceAddress,\n        string destinationChain,\n        string destinationAddress,\n        bytes32 indexed payloadHash,\n        string symbol,\n        uint256 amount,\n        uint256 gasFeeAmount,\n        address refundAddress\n    );\n\n    event GasAdded(\n        bytes32 indexed txHash,\n        uint256 indexed logIndex,\n        address gasToken,\n        uint256 gasFeeAmount,\n        address refundAddress\n    );\n\n    event NativeGasAdded(bytes32 indexed txHash, uint256 indexed logIndex, uint256 gasFeeAmount, address refundAddress);\n\n    event ExpressGasAdded(\n        bytes32 indexed txHash,\n        uint256 indexed logIndex,\n        address gasToken,\n        uint256 gasFeeAmount,\n        address refundAddress\n    );\n\n    event NativeExpressGasAdded(\n        bytes32 indexed txHash,\n        uint256 indexed logIndex,\n        uint256 gasFeeAmount,\n        address refundAddress\n    );\n\n    event Refunded(\n        bytes32 indexed txHash,\n        uint256 indexed logIndex,\n        address payable receiver,\n        address token,\n        uint256 amount\n    );\n\n    /**\n     * @notice Pay for gas for any type of contract execution on a destination chain.\n     * @dev This function is called on the source chain before calling the gateway to execute a remote contract.\n     * @dev If estimateOnChain is true, the function will estimate the gas cost and revert if the payment is insufficient.\n     * @param sender The address making the payment\n     * @param destinationChain The target chain where the contract call will be made\n     * @param destinationAddress The target address on the destination chain\n     * @param payload Data payload for the contract call\n     * @param executionGasLimit The gas limit for the contract call\n     * @param estimateOnChain Flag to enable on-chain gas estimation\n     * @param refundAddress The address where refunds, if any, should be sent\n     * @param params Additional parameters for gas payment. This can be left empty for normal contract call payments.\n     */\n    function payGas(\n        address sender,\n        string calldata destinationChain,\n        string calldata destinationAddress,\n        bytes calldata payload,\n        uint256 executionGasLimit,\n        bool estimateOnChain,\n        address refundAddress,\n        bytes calldata params\n    ) external payable;\n\n    /**\n     * @notice Pay for gas using ERC20 tokens for a contract call on a destination chain.\n     * @dev This function is called on the source chain before calling the gateway to execute a remote contract.\n     * @param sender The address making the payment\n     * @param destinationChain The target chain where the contract call will be made\n     * @param destinationAddress The target address on the destination chain\n     * @param payload Data payload for the contract call\n     * @param gasToken The address of the ERC20 token used to pay for gas\n     * @param gasFeeAmount The amount of tokens to pay for gas\n     * @param refundAddress The address where refunds, if any, should be sent\n     */\n    function payGasForContractCall(\n        address sender,\n        string calldata destinationChain,\n        string calldata destinationAddress,\n        bytes calldata payload,\n        address gasToken,\n        uint256 gasFeeAmount,\n        address refundAddress\n    ) external;\n\n    /**\n     * @notice Pay for gas using ERC20 tokens for a contract call with tokens on a destination chain.\n     * @dev This function is called on the source chain before calling the gateway to execute a remote contract.\n     * @param sender The address making the payment\n     * @param destinationChain The target chain where the contract call with tokens will be made\n     * @param destinationAddress The target address on the destination chain\n     * @param payload Data payload for the contract call with tokens\n     * @param symbol The symbol of the token to be sent with the call\n     * @param amount The amount of tokens to be sent with the call\n     * @param gasToken The address of the ERC20 token used to pay for gas\n     * @param gasFeeAmount The amount of tokens to pay for gas\n     * @param refundAddress The address where refunds, if any, should be sent\n     */\n    function payGasForContractCallWithToken(\n        address sender,\n        string calldata destinationChain,\n        string calldata destinationAddress,\n        bytes calldata payload,\n        string calldata symbol,\n        uint256 amount,\n        address gasToken,\n        uint256 gasFeeAmount,\n        address refundAddress\n    ) external;\n\n    /**\n     * @notice Pay for gas using native currency for a contract call on a destination chain.\n     * @dev This function is called on the source chain before calling the gateway to execute a remote contract.\n     * @param sender The address making the payment\n     * @param destinationChain The target chain where the contract call will be made\n     * @param destinationAddress The target address on the destination chain\n     * @param payload Data payload for the contract call\n     * @param refundAddress The address where refunds, if any, should be sent\n     */\n    function payNativeGasForContractCall(\n        address sender,\n        string calldata destinationChain,\n        string calldata destinationAddress,\n        bytes calldata payload,\n        address refundAddress\n    ) external payable;\n\n    /**\n     * @notice Pay for gas using native currency for a contract call with tokens on a destination chain.\n     * @dev This function is called on the source chain before calling the gateway to execute a remote contract.\n     * @param sender The address making the payment\n     * @param destinationChain The target chain where the contract call with tokens will be made\n     * @param destinationAddress The target address on the destination chain\n     * @param payload Data payload for the contract call with tokens\n     * @param symbol The symbol of the token to be sent with the call\n     * @param amount The amount of tokens to be sent with the call\n     * @param refundAddress The address where refunds, if any, should be sent\n     */\n    function payNativeGasForContractCallWithToken(\n        address sender,\n        string calldata destinationChain,\n        string calldata destinationAddress,\n        bytes calldata payload,\n        string calldata symbol,\n        uint256 amount,\n        address refundAddress\n    ) external payable;\n\n    /**\n     * @notice Pay for gas using ERC20 tokens for an express contract call on a destination chain.\n     * @dev This function is called on the source chain before calling the gateway to express execute a remote contract.\n     * @param sender The address making the payment\n     * @param destinationChain The target chain where the contract call will be made\n     * @param destinationAddress The target address on the destination chain\n     * @param payload Data payload for the contract call\n     * @param gasToken The address of the ERC20 token used to pay for gas\n     * @param gasFeeAmount The amount of tokens to pay for gas\n     * @param refundAddress The address where refunds, if any, should be sent\n     */\n    function payGasForExpressCall(\n        address sender,\n        string calldata destinationChain,\n        string calldata destinationAddress,\n        bytes calldata payload,\n        address gasToken,\n        uint256 gasFeeAmount,\n        address refundAddress\n    ) external;\n\n    /**\n     * @notice Pay for gas using ERC20 tokens for an express contract call with tokens on a destination chain.\n     * @dev This function is called on the source chain before calling the gateway to express execute a remote contract.\n     * @param sender The address making the payment\n     * @param destinationChain The target chain where the contract call with tokens will be made\n     * @param destinationAddress The target address on the destination chain\n     * @param payload Data payload for the contract call with tokens\n     * @param symbol The symbol of the token to be sent with the call\n     * @param amount The amount of tokens to be sent with the call\n     * @param gasToken The address of the ERC20 token used to pay for gas\n     * @param gasFeeAmount The amount of tokens to pay for gas\n     * @param refundAddress The address where refunds, if any, should be sent\n     */\n    function payGasForExpressCallWithToken(\n        address sender,\n        string calldata destinationChain,\n        string calldata destinationAddress,\n        bytes calldata payload,\n        string calldata symbol,\n        uint256 amount,\n        address gasToken,\n        uint256 gasFeeAmount,\n        address refundAddress\n    ) external;\n\n    /**\n     * @notice Pay for gas using native currency for an express contract call on a destination chain.\n     * @dev This function is called on the source chain before calling the gateway to execute a remote contract.\n     * @param sender The address making the payment\n     * @param destinationChain The target chain where the contract call will be made\n     * @param destinationAddress The target address on the destination chain\n     * @param payload Data payload for the contract call\n     * @param refundAddress The address where refunds, if any, should be sent\n     */\n    function payNativeGasForExpressCall(\n        address sender,\n        string calldata destinationChain,\n        string calldata destinationAddress,\n        bytes calldata payload,\n        address refundAddress\n    ) external payable;\n\n    /**\n     * @notice Pay for gas using native currency for an express contract call with tokens on a destination chain.\n     * @dev This function is called on the source chain before calling the gateway to execute a remote contract.\n     * @param sender The address making the payment\n     * @param destinationChain The target chain where the contract call with tokens will be made\n     * @param destinationAddress The target address on the destination chain\n     * @param payload Data payload for the contract call with tokens\n     * @param symbol The symbol of the token to be sent with the call\n     * @param amount The amount of tokens to be sent with the call\n     * @param refundAddress The address where refunds, if any, should be sent\n     */\n    function payNativeGasForExpressCallWithToken(\n        address sender,\n        string calldata destinationChain,\n        string calldata destinationAddress,\n        bytes calldata payload,\n        string calldata symbol,\n        uint256 amount,\n        address refundAddress\n    ) external payable;\n\n    /**\n     * @notice Add additional gas payment using ERC20 tokens after initiating a cross-chain call.\n     * @dev This function can be called on the source chain after calling the gateway to execute a remote contract.\n     * @param txHash The transaction hash of the cross-chain call\n     * @param logIndex The log index for the cross-chain call\n     * @param gasToken The ERC20 token address used to add gas\n     * @param gasFeeAmount The amount of tokens to add as gas\n     * @param refundAddress The address where refunds, if any, should be sent\n     */\n    function addGas(\n        bytes32 txHash,\n        uint256 logIndex,\n        address gasToken,\n        uint256 gasFeeAmount,\n        address refundAddress\n    ) external;\n\n    /**\n     * @notice Add additional gas payment using native currency after initiating a cross-chain call.\n     * @dev This function can be called on the source chain after calling the gateway to execute a remote contract.\n     * @param txHash The transaction hash of the cross-chain call\n     * @param logIndex The log index for the cross-chain call\n     * @param refundAddress The address where refunds, if any, should be sent\n     */\n    function addNativeGas(\n        bytes32 txHash,\n        uint256 logIndex,\n        address refundAddress\n    ) external payable;\n\n    /**\n     * @notice Add additional gas payment using ERC20 tokens after initiating an express cross-chain call.\n     * @dev This function can be called on the source chain after calling the gateway to express execute a remote contract.\n     * @param txHash The transaction hash of the cross-chain call\n     * @param logIndex The log index for the cross-chain call\n     * @param gasToken The ERC20 token address used to add gas\n     * @param gasFeeAmount The amount of tokens to add as gas\n     * @param refundAddress The address where refunds, if any, should be sent\n     */\n    function addExpressGas(\n        bytes32 txHash,\n        uint256 logIndex,\n        address gasToken,\n        uint256 gasFeeAmount,\n        address refundAddress\n    ) external;\n\n    /**\n     * @notice Add additional gas payment using native currency after initiating an express cross-chain call.\n     * @dev This function can be called on the source chain after calling the gateway to express execute a remote contract.\n     * @param txHash The transaction hash of the cross-chain call\n     * @param logIndex The log index for the cross-chain call\n     * @param refundAddress The address where refunds, if any, should be sent\n     */\n    function addNativeExpressGas(\n        bytes32 txHash,\n        uint256 logIndex,\n        address refundAddress\n    ) external payable;\n\n    /**\n     * @notice Updates the gas price for a specific chain.\n     * @dev This function is called by the gas oracle to update the gas prices for a specific chains.\n     * @param chains Array of chain names\n     * @param gasUpdates Array of gas updates\n     */\n    function updateGasInfo(string[] calldata chains, GasInfo[] calldata gasUpdates) external;\n\n    /**\n     * @notice Allows the gasCollector to collect accumulated fees from the contract.\n     * @dev Use address(0) as the token address for native currency.\n     * @param receiver The address to receive the collected fees\n     * @param tokens Array of token addresses to be collected\n     * @param amounts Array of amounts to be collected for each respective token address\n     */\n    function collectFees(\n        address payable receiver,\n        address[] calldata tokens,\n        uint256[] calldata amounts\n    ) external;\n\n    /**\n     * @notice Refunds gas payment to the receiver in relation to a specific cross-chain transaction.\n     * @dev Only callable by the gasCollector.\n     * @dev Use address(0) as the token address to refund native currency.\n     * @param txHash The transaction hash of the cross-chain call\n     * @param logIndex The log index for the cross-chain call\n     * @param receiver The address to receive the refund\n     * @param token The token address to be refunded\n     * @param amount The amount to refund\n     */\n    function refund(\n        bytes32 txHash,\n        uint256 logIndex,\n        address payable receiver,\n        address token,\n        uint256 amount\n    ) external;\n\n    /**\n     * @notice Returns the address of the designated gas collector.\n     * @return address of the gas collector\n     */\n    function gasCollector() external returns (address);\n}\n"
    },
    "@axelar-network/axelar-gmp-sdk-solidity/contracts/interfaces/IAxelarGateway.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport { IGovernable } from './IGovernable.sol';\nimport { IImplementation } from './IImplementation.sol';\n\ninterface IAxelarGateway is IImplementation, IGovernable {\n    /**********\\\n    |* Errors *|\n    \\**********/\n\n    error NotSelf();\n    error InvalidCodeHash();\n    error SetupFailed();\n    error InvalidAuthModule();\n    error InvalidTokenDeployer();\n    error InvalidAmount();\n    error InvalidChainId();\n    error InvalidCommands();\n    error TokenDoesNotExist(string symbol);\n    error TokenAlreadyExists(string symbol);\n    error TokenDeployFailed(string symbol);\n    error TokenContractDoesNotExist(address token);\n    error BurnFailed(string symbol);\n    error MintFailed(string symbol);\n    error InvalidSetMintLimitsParams();\n    error ExceedMintLimit(string symbol);\n\n    /**********\\\n    |* Events *|\n    \\**********/\n\n    event TokenSent(\n        address indexed sender,\n        string destinationChain,\n        string destinationAddress,\n        string symbol,\n        uint256 amount\n    );\n\n    event ContractCall(\n        address indexed sender,\n        string destinationChain,\n        string destinationContractAddress,\n        bytes32 indexed payloadHash,\n        bytes payload\n    );\n\n    event ContractCallWithToken(\n        address indexed sender,\n        string destinationChain,\n        string destinationContractAddress,\n        bytes32 indexed payloadHash,\n        bytes payload,\n        string symbol,\n        uint256 amount\n    );\n\n    event Executed(bytes32 indexed commandId);\n\n    event TokenDeployed(string symbol, address tokenAddresses);\n\n    event ContractCallApproved(\n        bytes32 indexed commandId,\n        string sourceChain,\n        string sourceAddress,\n        address indexed contractAddress,\n        bytes32 indexed payloadHash,\n        bytes32 sourceTxHash,\n        uint256 sourceEventIndex\n    );\n\n    event ContractCallApprovedWithMint(\n        bytes32 indexed commandId,\n        string sourceChain,\n        string sourceAddress,\n        address indexed contractAddress,\n        bytes32 indexed payloadHash,\n        string symbol,\n        uint256 amount,\n        bytes32 sourceTxHash,\n        uint256 sourceEventIndex\n    );\n\n    event ContractCallExecuted(bytes32 indexed commandId);\n\n    event TokenMintLimitUpdated(string symbol, uint256 limit);\n\n    event OperatorshipTransferred(bytes newOperatorsData);\n\n    event Upgraded(address indexed implementation);\n\n    /********************\\\n    |* Public Functions *|\n    \\********************/\n\n    function sendToken(\n        string calldata destinationChain,\n        string calldata destinationAddress,\n        string calldata symbol,\n        uint256 amount\n    ) external;\n\n    function callContract(\n        string calldata destinationChain,\n        string calldata contractAddress,\n        bytes calldata payload\n    ) external;\n\n    function callContractWithToken(\n        string calldata destinationChain,\n        string calldata contractAddress,\n        bytes calldata payload,\n        string calldata symbol,\n        uint256 amount\n    ) external;\n\n    function isContractCallApproved(\n        bytes32 commandId,\n        string calldata sourceChain,\n        string calldata sourceAddress,\n        address contractAddress,\n        bytes32 payloadHash\n    ) external view returns (bool);\n\n    function isContractCallAndMintApproved(\n        bytes32 commandId,\n        string calldata sourceChain,\n        string calldata sourceAddress,\n        address contractAddress,\n        bytes32 payloadHash,\n        string calldata symbol,\n        uint256 amount\n    ) external view returns (bool);\n\n    function validateContractCall(\n        bytes32 commandId,\n        string calldata sourceChain,\n        string calldata sourceAddress,\n        bytes32 payloadHash\n    ) external returns (bool);\n\n    function validateContractCallAndMint(\n        bytes32 commandId,\n        string calldata sourceChain,\n        string calldata sourceAddress,\n        bytes32 payloadHash,\n        string calldata symbol,\n        uint256 amount\n    ) external returns (bool);\n\n    /***********\\\n    |* Getters *|\n    \\***********/\n\n    function authModule() external view returns (address);\n\n    function tokenDeployer() external view returns (address);\n\n    function tokenMintLimit(string memory symbol) external view returns (uint256);\n\n    function tokenMintAmount(string memory symbol) external view returns (uint256);\n\n    function allTokensFrozen() external view returns (bool);\n\n    function implementation() external view returns (address);\n\n    function tokenAddresses(string memory symbol) external view returns (address);\n\n    function tokenFrozen(string memory symbol) external view returns (bool);\n\n    function isCommandExecuted(bytes32 commandId) external view returns (bool);\n\n    /************************\\\n    |* Governance Functions *|\n    \\************************/\n\n    function setTokenMintLimits(string[] calldata symbols, uint256[] calldata limits) external;\n\n    function upgrade(\n        address newImplementation,\n        bytes32 newImplementationCodeHash,\n        bytes calldata setupParams\n    ) external;\n\n    /**********************\\\n    |* External Functions *|\n    \\**********************/\n\n    function execute(bytes calldata input) external;\n}\n"
    },
    "@axelar-network/axelar-gmp-sdk-solidity/contracts/interfaces/IContractIdentifier.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n// General interface for upgradable contracts\ninterface IContractIdentifier {\n    /**\n     * @notice Returns the contract ID. It can be used as a check during upgrades.\n     * @dev Meant to be overridden in derived contracts.\n     * @return bytes32 The contract ID\n     */\n    function contractId() external pure returns (bytes32);\n}\n"
    },
    "@axelar-network/axelar-gmp-sdk-solidity/contracts/interfaces/IGovernable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @title IGovernable Interface\n * @notice This is an interface used by the AxelarGateway contract to manage governance and mint limiter roles.\n */\ninterface IGovernable {\n    error NotGovernance();\n    error NotMintLimiter();\n    error InvalidGovernance();\n    error InvalidMintLimiter();\n\n    event GovernanceTransferred(address indexed previousGovernance, address indexed newGovernance);\n    event MintLimiterTransferred(address indexed previousGovernance, address indexed newGovernance);\n\n    /**\n     * @notice Returns the governance address.\n     * @return address of the governance\n     */\n    function governance() external view returns (address);\n\n    /**\n     * @notice Returns the mint limiter address.\n     * @return address of the mint limiter\n     */\n    function mintLimiter() external view returns (address);\n\n    /**\n     * @notice Transfer the governance role to another address.\n     * @param newGovernance The new governance address\n     */\n    function transferGovernance(address newGovernance) external;\n\n    /**\n     * @notice Transfer the mint limiter role to another address.\n     * @param newGovernance The new mint limiter address\n     */\n    function transferMintLimiter(address newGovernance) external;\n}\n"
    },
    "@axelar-network/axelar-gmp-sdk-solidity/contracts/interfaces/IImplementation.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport { IContractIdentifier } from './IContractIdentifier.sol';\n\ninterface IImplementation is IContractIdentifier {\n    error NotProxy();\n\n    function setup(bytes calldata data) external;\n}\n"
    },
    "@axelar-network/axelar-gmp-sdk-solidity/contracts/interfaces/IInterchainGasEstimation.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport { GasEstimationType, GasInfo } from '../types/GasEstimationTypes.sol';\n\n/**\n * @title IInterchainGasEstimation Interface\n * @notice This is an interface for the InterchainGasEstimation contract\n * which allows for estimating gas fees for cross-chain communication on the Axelar network.\n */\ninterface IInterchainGasEstimation {\n    error UnsupportedEstimationType(GasEstimationType gasEstimationType);\n\n    /**\n     * @notice Event emitted when the gas price for a specific chain is updated.\n     * @param chain The name of the chain\n     * @param info The gas info for the chain\n     */\n    event GasInfoUpdated(string chain, GasInfo info);\n\n    /**\n     * @notice Returns the gas price for a specific chain.\n     * @param chain The name of the chain\n     * @return gasInfo The gas info for the chain\n     */\n    function getGasInfo(string calldata chain) external view returns (GasInfo memory);\n\n    /**\n     * @notice Estimates the gas fee for a cross-chain contract call.\n     * @param destinationChain Axelar registered name of the destination chain\n     * @param destinationAddress Destination contract address being called\n     * @param executionGasLimit The gas limit to be used for the destination contract execution,\n     *        e.g. pass in 200k if your app consumes needs upto 200k for this contract call\n     * @param params Additional parameters for the gas estimation\n     * @return gasEstimate The cross-chain gas estimate, in terms of source chain's native gas token that should be forwarded to the gas service.\n     */\n    function estimateGasFee(\n        string calldata destinationChain,\n        string calldata destinationAddress,\n        bytes calldata payload,\n        uint256 executionGasLimit,\n        bytes calldata params\n    ) external view returns (uint256 gasEstimate);\n}\n"
    },
    "@axelar-network/axelar-gmp-sdk-solidity/contracts/interfaces/IOwnable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @title IOwnable Interface\n * @notice IOwnable is an interface that abstracts the implementation of a\n * contract with ownership control features. It's commonly used in upgradable\n * contracts and includes the functionality to get current owner, transfer\n * ownership, and propose and accept ownership.\n */\ninterface IOwnable {\n    error NotOwner();\n    error InvalidOwner();\n    error InvalidOwnerAddress();\n\n    event OwnershipTransferStarted(address indexed newOwner);\n    event OwnershipTransferred(address indexed newOwner);\n\n    /**\n     * @notice Returns the current owner of the contract.\n     * @return address The address of the current owner\n     */\n    function owner() external view returns (address);\n\n    /**\n     * @notice Returns the address of the pending owner of the contract.\n     * @return address The address of the pending owner\n     */\n    function pendingOwner() external view returns (address);\n\n    /**\n     * @notice Transfers ownership of the contract to a new address\n     * @param newOwner The address to transfer ownership to\n     */\n    function transferOwnership(address newOwner) external;\n\n    /**\n     * @notice Proposes to transfer the contract's ownership to a new address.\n     * The new owner needs to accept the ownership explicitly.\n     * @param newOwner The address to transfer ownership to\n     */\n    function proposeOwnership(address newOwner) external;\n\n    /**\n     * @notice Transfers ownership to the pending owner.\n     * @dev Can only be called by the pending owner\n     */\n    function acceptOwnership() external;\n}\n"
    },
    "@axelar-network/axelar-gmp-sdk-solidity/contracts/interfaces/IUpgradable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport { IOwnable } from './IOwnable.sol';\nimport { IImplementation } from './IImplementation.sol';\n\n// General interface for upgradable contracts\ninterface IUpgradable is IOwnable, IImplementation {\n    error InvalidCodeHash();\n    error InvalidImplementation();\n    error SetupFailed();\n\n    event Upgraded(address indexed newImplementation);\n\n    function implementation() external view returns (address);\n\n    function upgrade(\n        address newImplementation,\n        bytes32 newImplementationCodeHash,\n        bytes calldata params\n    ) external;\n}\n"
    },
    "@axelar-network/axelar-gmp-sdk-solidity/contracts/types/GasEstimationTypes.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @title GasEstimationType\n * @notice This enum represents the gas estimation types for different chains.\n */\nenum GasEstimationType {\n    Default,\n    OptimismEcotone,\n    OptimismBedrock,\n    Arbitrum,\n    Scroll\n}\n\n/**\n * @title GasInfo\n * @notice This struct represents the gas pricing information for a specific chain.\n * @dev Smaller uint types are used for efficient struct packing to save storage costs.\n */\nstruct GasInfo {\n    /// @dev Custom gas pricing rule, such as L1 data fee on L2s\n    uint64 gasEstimationType;\n    /// @dev Scalar value needed for specific gas estimation types, expected to be less than 1e10\n    uint64 l1FeeScalar;\n    /// @dev Axelar base fee for cross-chain message approval on destination, in terms of source native gas token\n    uint128 axelarBaseFee;\n    /// @dev Gas price of destination chain, in terms of the source chain token, i.e dest_gas_price * dest_token_market_price / src_token_market_price\n    uint128 relativeGasPrice;\n    /// @dev Needed for specific gas estimation types. Blob base fee of destination chain, in terms of the source chain token, i.e dest_blob_base_fee * dest_token_market_price / src_token_market_price\n    uint128 relativeBlobBaseFee;\n    /// @dev Axelar express fee for express execution, in terms of source chain token\n    uint128 expressFee;\n}\n"
    },
    "contracts/TicTacAvax.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.24;\n\ncontract TicTacAvax {\n\taddress[2] public players;\n\tuint public currentPlayer;\n\tuint8[3][3] public board;\n\tuint public roundCount;\n\tuint public gameCount;\n\tbool public gameOver;\n\taddress public winner;\n\tuint public lastMoveTimestamp;\n\taddress public lastRoundWinner;\n\n\tevent GameStarted(address player1, address player2);\n\tevent MoveMade(address player, uint8 row, uint8 col);\n\tevent GameWon(address winner);\n\tevent GameDraw();\n\tevent GameReset();\n\n\tmodifier onlyPlayers() {\n\t\trequire(\n\t\t\tmsg.sender == players[0] || msg.sender == players[1],\n\t\t\t'Not a player'\n\t\t);\n\t\t_;\n\t}\n\n\tmodifier validMove(uint8 row, uint8 col) {\n\t\trequire(!gameOver, 'Game over');\n\t\trequire(row < 3 && col < 3, 'Invalid move');\n\t\trequire(board[row][col] == 0, 'Cell already taken');\n\t\t_;\n\t}\n\n\tconstructor() {}\n\n\tfunction startGame(address playerOne, address playerTwo) public {\n\t\trequire(\n\t\t\tplayers[0] == address(0) && players[1] == address(0),\n\t\t\t'Game already started'\n\t\t);\n\t\trequire(\n\t\t\tplayerOne != address(0) && playerTwo != address(0),\n\t\t\t'Invalid player'\n\t\t);\n\t\trequire(playerOne != playerTwo, 'Players must be different');\n\n\t\tplayers[0] = playerOne;\n\t\tplayers[1] = playerTwo;\n\t\tcurrentPlayer = 0;\n\t\tgameOver = false;\n\t\troundCount++;\n\t\tlastMoveTimestamp = block.timestamp;\n\n\t\temit GameStarted(playerOne, playerTwo);\n\t}\n\n\tfunction makeMove(\n\t\tuint8 row,\n\t\tuint8 col\n\t) public onlyPlayers validMove(row, col) {\n\t\trequire(msg.sender == players[currentPlayer], 'Not your turn');\n\n\t\tboard[row][col] = uint8(currentPlayer + 1);\n\t\temit MoveMade(msg.sender, row, col);\n\n\t\tif (checkWin()) {\n\t\t\tgameOver = true;\n\t\t\twinner = msg.sender;\n\t\t\tlastRoundWinner = msg.sender;\n\t\t\temit GameWon(msg.sender);\n\t\t} else if (checkDraw()) {\n\t\t\tgameOver = true;\n\t\t\temit GameDraw();\n\t\t} else {\n\t\t\tcurrentPlayer = 1 - currentPlayer;\n\t\t}\n\n\t\tlastMoveTimestamp = block.timestamp;\n\t\troundCount++;\n\t}\n\n\tfunction checkWin() internal view returns (bool) {\n\t\tfor (uint8 i = 0; i < 3; i++) {\n\t\t\tif (\n\t\t\t\t(board[i][0] == board[i][1] &&\n\t\t\t\t\tboard[i][1] == board[i][2] &&\n\t\t\t\t\tboard[i][0] != 0) ||\n\t\t\t\t(board[0][i] == board[1][i] &&\n\t\t\t\t\tboard[1][i] == board[2][i] &&\n\t\t\t\t\tboard[0][i] != 0)\n\t\t\t) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\tif (\n\t\t\t(board[0][0] == board[1][1] &&\n\t\t\t\tboard[1][1] == board[2][2] &&\n\t\t\t\tboard[0][0] != 0) ||\n\t\t\t(board[0][2] == board[1][1] &&\n\t\t\t\tboard[1][1] == board[2][0] &&\n\t\t\t\tboard[0][2] != 0)\n\t\t) {\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\n\tfunction checkDraw() internal view returns (bool) {\n\t\tfor (uint8 i = 0; i < 3; i++) {\n\t\t\tfor (uint8 j = 0; j < 3; j++) {\n\t\t\t\tif (board[i][j] == 0) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn !checkWin();\n\t}\n\n\tfunction resetGame() public {\n\t\trequire(\n\t\t\tgameOver || block.timestamp > lastMoveTimestamp + 86400,\n\t\t\t'Game is not over yet or 24 hours have not passed'\n\t\t);\n\n\t\tfor (uint8 i = 0; i < 3; i++) {\n\t\t\tfor (uint8 j = 0; j < 3; j++) {\n\t\t\t\tboard[i][j] = 0;\n\t\t\t}\n\t\t}\n\n\t\tgameOver = false;\n\t\tcurrentPlayer = 0;\n\t\troundCount = 0;\n\t\twinner = address(0);\n\t\tlastMoveTimestamp = block.timestamp;\n\t\tplayers[0] = address(0);\n\t\tplayers[1] = address(0);\n\n\t\temit GameReset();\n\t}\n\n\tfunction getBoard() public view returns (uint8[3][3] memory) {\n\t\treturn board;\n\t}\n}\n"
    },
    "contracts/TicTacAvaxCross.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.24;\n\nimport {AxelarExecutable} from '@axelar-network/axelar-gmp-sdk-solidity/contracts/executable/AxelarExecutable.sol';\nimport {IAxelarGateway} from '@axelar-network/axelar-gmp-sdk-solidity/contracts/interfaces/IAxelarGateway.sol';\nimport {IAxelarGasService} from '@axelar-network/axelar-gmp-sdk-solidity/contracts/interfaces/IAxelarGasService.sol';\n\ncontract TicTacAvaxCross is AxelarExecutable {\n\tIAxelarGasService public immutable gasService;\n\tstring public message;\n\n\taddress[2] public players;\n\tuint public currentPlayer;\n\tuint8[3][3] public board;\n\tuint public roundCount;\n\tuint public gameCount;\n\tbool public gameOver;\n\taddress public winner;\n\tuint public lastMoveTimestamp;\n\taddress public lastRoundWinner;\n\n\tevent GameStarted(address player1, address player2);\n\tevent MoveMade(address player, uint8 row, uint8 col);\n\tevent GameWon(address winner);\n\tevent GameDraw();\n\tevent GameReset();\n\n\tmodifier onlyPlayers() {\n\t\trequire(\n\t\t\tmsg.sender == players[0] || msg.sender == players[1],\n\t\t\t'Not a player'\n\t\t);\n\t\t_;\n\t}\n\n\tmodifier validMove(uint8 row, uint8 col) {\n\t\trequire(!gameOver, 'Game over');\n\t\trequire(row < 3 && col < 3, 'Invalid move');\n\t\trequire(board[row][col] == 0, 'Cell already taken');\n\t\t_;\n\t}\n\n\tconstructor(\n\t\taddress _gateway,\n\t\taddress _gasService\n\t) AxelarExecutable(_gateway) {\n\t\tgasService = IAxelarGasService(_gasService);\n\t}\n\n\tfunction startGame(\n\t\tstring calldata _destinationChain,\n\t\tstring calldata _destinationAddress,\n\t\taddress playerOne,\n\t\taddress playerTwo\n\t) public payable {\n\t\trequire(\n\t\t\tplayers[0] == address(0) && players[1] == address(0),\n\t\t\t'Game already started'\n\t\t);\n\t\trequire(\n\t\t\tplayerOne != address(0) && playerTwo != address(0),\n\t\t\t'Invalid player'\n\t\t);\n\t\trequire(playerOne != playerTwo, 'Players must be different');\n\n\t\t(string memory flag, address _playerOne, address _playerTwo) = _startGame(\n\t\t\tplayerOne,\n\t\t\tplayerTwo\n\t\t);\n\n\t\tbytes memory payload = abi.encode(flag, _playerOne, _playerTwo);\n\n\t\tgasService.payNativeGasForContractCall{value: msg.value}(\n\t\t\taddress(this),\n\t\t\t_destinationChain,\n\t\t\t_destinationAddress,\n\t\t\tpayload,\n\t\t\tmsg.sender\n\t\t);\n\n\t\tgateway.callContract(_destinationChain, _destinationAddress, payload);\n\t}\n\n\tfunction makeMove(\n\t\tstring calldata _destinationChain,\n\t\tstring calldata _destinationAddress,\n\t\tuint8 _row,\n\t\tuint8 _col\n\t) public payable onlyPlayers validMove(_row, _col) {\n\t\trequire(msg.sender == players[currentPlayer], 'Not your turn');\n\n\t\tstring memory flag = _makeMove(_row, _col);\n\n\t\tbytes memory payload = abi.encode(flag, _row, _col);\n\n\t\tgasService.payNativeGasForContractCall{value: msg.value}(\n\t\t\taddress(this),\n\t\t\t_destinationChain,\n\t\t\t_destinationAddress,\n\t\t\tpayload,\n\t\t\tmsg.sender\n\t\t);\n\n\t\tgateway.callContract(_destinationChain, _destinationAddress, payload);\n\t}\n\n\tfunction resetGame(\n\t\tstring calldata _destinationChain,\n\t\tstring calldata _destinationAddress\n\t) public payable {\n\t\trequire(\n\t\t\tgameOver || block.timestamp > lastMoveTimestamp + 86400,\n\t\t\t'Game is not over yet or 24 hours have not passed'\n\t\t);\n\n\t\tstring memory flag = _resetGame();\n\n\t\tbytes memory payload = abi.encode(flag);\n\n\t\tgasService.payNativeGasForContractCall{value: msg.value}(\n\t\t\taddress(this),\n\t\t\t_destinationChain,\n\t\t\t_destinationAddress,\n\t\t\tpayload,\n\t\t\tmsg.sender\n\t\t);\n\n\t\tgateway.callContract(_destinationChain, _destinationAddress, payload);\n\t}\n\n\t/// View functions\n\n\tfunction getBoard() public view returns (uint8[3][3] memory) {\n\t\treturn board;\n\t}\n\n\t/// internal functions\n\n\tfunction checkWin() internal view returns (bool) {\n\t\tfor (uint8 i = 0; i < 3; i++) {\n\t\t\tif (\n\t\t\t\t(board[i][0] == board[i][1] &&\n\t\t\t\t\tboard[i][1] == board[i][2] &&\n\t\t\t\t\tboard[i][0] != 0) ||\n\t\t\t\t(board[0][i] == board[1][i] &&\n\t\t\t\t\tboard[1][i] == board[2][i] &&\n\t\t\t\t\tboard[0][i] != 0)\n\t\t\t) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\tif (\n\t\t\t(board[0][0] == board[1][1] &&\n\t\t\t\tboard[1][1] == board[2][2] &&\n\t\t\t\tboard[0][0] != 0) ||\n\t\t\t(board[0][2] == board[1][1] &&\n\t\t\t\tboard[1][1] == board[2][0] &&\n\t\t\t\tboard[0][2] != 0)\n\t\t) {\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\n\tfunction checkDraw() internal view returns (bool) {\n\t\tfor (uint8 i = 0; i < 3; i++) {\n\t\t\tfor (uint8 j = 0; j < 3; j++) {\n\t\t\t\tif (board[i][j] == 0) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn !checkWin();\n\t}\n\n\tfunction _execute(\n\t\tstring calldata sourceChain,\n\t\tstring calldata sourceAddress,\n\t\tbytes calldata _payload\n\t) internal override {\n\t\tstring memory flag = abi.decode(_payload, (string));\n\n\t\tif (\n\t\t\tkeccak256(abi.encodePacked(flag)) ==\n\t\t\tkeccak256(abi.encodePacked('startGame'))\n\t\t) {\n\t\t\t(string memory failFlag, address playerOne, address playerTwo) = abi\n\t\t\t\t.decode(_payload, (string, address, address));\n\n\t\t\t_startGame(playerOne, playerTwo);\n\t\t} else if (\n\t\t\tkeccak256(abi.encodePacked(flag)) ==\n\t\t\tkeccak256(abi.encodePacked('makeMove'))\n\t\t) {\n\t\t\t(string memory failFlag, uint8 _row, uint8 _col) = abi.decode(\n\t\t\t\t_payload,\n\t\t\t\t(string, uint8, uint8)\n\t\t\t);\n\n\t\t\t_makeMove(_row, _col);\n\t\t} else if (\n\t\t\tkeccak256(abi.encodePacked(flag)) ==\n\t\t\tkeccak256(abi.encodePacked('resetGame'))\n\t\t) {\n\t\t\t_resetGame();\n\t\t}\n\t}\n\n\t//// Private functions\n\n\tfunction _startGame(\n\t\taddress _playerOne,\n\t\taddress _playerTwo\n\t) private returns (string memory, address, address) {\n\t\tstring memory flag = 'startGame';\n\n\t\tplayers[0] = _playerOne;\n\t\tplayers[1] = _playerTwo;\n\t\tcurrentPlayer = 0;\n\t\tgameOver = false;\n\t\tlastMoveTimestamp = block.timestamp;\n\t\tgameCount++;\n\n\t\temit GameStarted(_playerOne, _playerTwo);\n\n\t\treturn (flag, _playerOne, _playerTwo);\n\t}\n\n\tfunction _makeMove(uint8 _row, uint8 _col) private returns (string memory) {\n\t\tstring memory flag = 'makeMove';\n\n\t\tboard[_row][_col] = uint8(currentPlayer + 1);\n\t\temit MoveMade(msg.sender, _row, _col);\n\n\t\tif (checkWin()) {\n\t\t\tgameOver = true;\n\t\t\twinner = msg.sender;\n\t\t\tlastRoundWinner = msg.sender;\n\t\t\temit GameWon(msg.sender);\n\t\t} else if (checkDraw()) {\n\t\t\tgameOver = true;\n\t\t\temit GameDraw();\n\t\t} else {\n\t\t\tcurrentPlayer = 1 - currentPlayer;\n\t\t}\n\n\t\tlastMoveTimestamp = block.timestamp;\n\n\t\treturn flag;\n\t}\n\n\tfunction _resetGame() private returns (string memory) {\n\t\tstring memory flag = 'resetGame';\n\n\t\tfor (uint8 i = 0; i < 3; i++) {\n\t\t\tfor (uint8 j = 0; j < 3; j++) {\n\t\t\t\tboard[i][j] = 0;\n\t\t\t}\n\t\t}\n\n\t\tgameOver = false;\n\t\tcurrentPlayer = 0;\n\t\troundCount = 0;\n\t\twinner = address(0);\n\t\tlastMoveTimestamp = block.timestamp;\n\t\tplayers[0] = address(0);\n\t\tplayers[1] = address(0);\n\n\t\temit GameReset();\n\n\t\treturn flag;\n\t}\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "evmVersion": "paris",
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "storageLayout",
          "devdoc",
          "userdoc",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}